\chapter{演算法分析}\label{se_4}
一個好的共識演算法必須具備安全性（Safety）與活性（Liveness），才能讓該系統保持內容一致，並且保證安全且永不出錯。
\section{安全性（Safety）}\label{se_4} 
共識演算法必須要確保整個網路不會有分支（Fork）產生，以確保區塊鏈的安全性。為了證明我們的演算法能夠確保安全性，我們需要證明以下兩個定理。
\begin{itemize}%项目符号开始
\item 如果兩個非故障節點$u_{1}$和$u_{2}$分別在同一回合$r$中提交值$b_{1}$和$b_{2}$，則$b_{1} = b_{2}$。

證明:我們使用反證法，首先假設$b_{1}\ne b_{2}$，如果有一節點$u_{1}$收到$4f+1$張提交$b_{1}$的選票；與$u_{1}$相同的$u_{2}$收到$4f+1$張提交$b_{2}$的選票。因為扣除掉可能重複投票的錯誤節點數$f$，在回合$r$裡至少有$3f+1$個非故障節點投給$b_{1}$；相同的扣除掉可能重複投票的錯誤節點數$f$，在回合$r$裡至少有$3f+1$個非故障節點投給$b_{2}$。兩個集合共$6f+2 > 4f+1$（非故障節點個數）。非故障節點一回合只會對一個提議投票，故矛盾。

\item 一旦有一個非錯誤的節點在$r$回合成功的提交了區塊$b$時，在未來的回合$r'$，此$r'>r$，只有區塊$b$能被提交。

證明:假設$N_{b}$是在第$r$回合中投票給$b$的節點集合。因為$b$是在回合$r$中被提交，代表$|N_{b}| \geqq 4f+1$。假設$G_{b}$是僅包含非故障節點的$N_{b}$的子集。因此，$|G_{b}| \geqq 3f+1$。根據演算法規定，我們能夠觀察到如果$r + 1$回合的廣播者擁有$r$回合的有效票集合，那麼此票集合必須至少包含從$G_{b}$發送的$2f + 1$個投票消息。此外，對於每個候選值，假設$b_{1}\ne b_{2}$，最多只有$2f$張票在票集合中的投票信息有包含$b2$。因此，如果下回合$r=r+1$的廣播者可以發送提案$p$，該$p.B$必須維持是$b1$。否則，如果$r+ 1$回合沒有Proposal，則$Gb$中的所有節點，仍會投票支持他們在第$r$輪投票的值，即$b1$。在這兩種情況下，$Gb$中的所有節點仍然投票對於$r+ 1$回合中的$b$，然後通過歸納進行Commit。
\end{itemize}

\section{活性（Liveness）}\label{se_4} 
我們能夠證明演算法可以保證在部分同步模型（Partially Synchronous Model）下，能夠保有的活性。

在部分同步模型的假設裡，我們假設每回合的Timeout時間都會加倍。在部分同步模型下，存在一些回合$r$。並且這些$r<r'$
所有非故障節點都可以在Timeout前接收到彼此傳來的訊息。因此，在這些$r$的下一回合$r + 1<r'$回合中，如果廣播者是非故障節點
那麼廣播者必須有一個有效的票集合，並且必須有一個有效的Proposal消息。然後，所有$4f +1$非故障節點在$r'$回合中投票給$p.b$。 由於所有這些$4f +1$投票
消息可以及時接收，所有非故障節點都可以在循環$r'$中提交$p.b$。
