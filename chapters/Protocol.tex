\chapter{安全性及活性}\label{se_4}
一個好的共識演算法必須具備安全性(SAFETY)與活性(LIVENESS)，才能讓該系統保持內容一致，並且保證安全且永不出錯。
\section{安全性(SAFETY)}\label{se_4} 
共識演算法必須要確保整個網路不會有分支（Fork）產生，以確保區塊鏈的安全性。為了證明我們的演算法能夠確保安全性，我們需要證明以下兩個定理。
\begin{itemize}%项目符号开始
\item 如果兩個非故障節點$u$1和$u$2分別在同一回合$r$中提交值$b$1和$b$2，則$b$1 = $b$2。

證明:我們使用反證法，首先假設$b$1 $\ne$ $b$2，如果有一節點$u$1收到4$f$+1張提交$b$1的選票；與$u$1相同的$u$2收到4$f$+1張提交$b$2的選票。因為扣除掉可能重複投票的錯誤節點數$f$，在回合$r$裡至少有3$f$+1個非故障節點投給b1；相同的扣除掉可能重複投票的錯誤節點數$f$，在回合$r$裡至少有3$f$+1個非故障節點投給$b$2。兩個集合共6$f$+2 > 4$f$+1(非故障節點個數)。非故障節點一回合只會對一個提議投票，故矛盾。

\item 一旦有一個非錯誤的節點在$r$回合成功的提交了區塊$B$時，在未來的回合$r`$，此$r`$>$r$，只有區塊$B$能被提交。

證明:假設$Nb$是在第$r$回合中投票給$b$的節點集合。因為$b$是在回合$r$中被提交，代表|$Nb$| $\geqq$ 4$f$+1。假設$Gb$是僅包含非故障節點的$Nb$的子集。因此，|$Gb$| $\geqq$ 3$f$ +1。根據演算法規定，我們能夠觀察到如果$r$ + 1回合的廣播者擁有$r$回合的有效Lockset，那麼此Lockset必須至少包含從$Gb$發送的2$f$ + 1個投票消息。此外，對於每個候選值，假設$b$1 $\ne$ $b$2，最多只有2$f$張票在Lockset中的投票信息有包含$b$2。因此，如果下回合$r$=$r$+1的廣播者可以發送提案$p$，該$p.B$必須維持是$b$1。否則，如果$r$ + 1回合沒有Proposal，則Gb中的所有節點，仍會投票支持他們在第$r$輪投票的值，即$b$1。在這兩種情況下，$Gb$中的所有節點仍然投票對於$r$ + 1回合中的b，然後通過歸納進行Commit。
\end{itemize}

\section{活性(LIVENESS)}\label{se_4} 
我們能夠證明演算法可以保證在部分同步模型（Partially Synchronous Model）下，能夠保有的活性。

在部分同步模型的假設裡，我們假設每回合的Timeout時間都會加倍。在部分同步模型下，存在一些回合r。並且這些$r$<$r'$
所有非故障節點都可以在Timeout前接收到彼此傳來的訊息。因此,在這些$r$的下一回合$r$ + 1<$r'$回合中，如果廣播者是非故障節點
那麼廣播者必須有一個有效的lockset，並且必須有一個有效的Proposal消息。然後，所有4$f$ +1非故障節點在$r'$回合中投票給$p,B$。 由於所有這些4$f$ +1投票
消息可以及時接收，所有非故障節點都可以在循環$r'$中提交$p,B$。